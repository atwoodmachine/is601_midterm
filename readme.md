## IS 601 Midterm
Seniz Ozdemir

### Calculator App Setup and Usage

Install dependencies with ```pip install -r requirements.txt```. Run the calculator program in the command line with ```python main.py```. The calculator saves history by default in the app's ./history directory in the file calculation_history.csv. To change this filepath, configure a .env file to set the environment variables HISTORY_DIR and HISTORY_FILE to the desired directory and to the desired file name respectively. The path for logging is also set with an environment variable, defaulting to logging.conf. Here is an example .env file:

```
HISTORY_DIR = ./history 
HISTORY_FILE = calculation_history.csv
LOGGING_CONF_PATH = logging.conf
```

### Pytest and Faker
Additional test cases may be generated by faker using the ```num_records``` argument with pytest. For example, ```pytest --num_records=25``` to generate 25 additional calculation tests on top of the existing test suite.

### Design
The calculator app allows users to perform four basic arithmetic operations: add, subtract, multiply, and divide. The calculator saves every successful operation and allows users to view the operation history, clear it, and delete specific entries.<br>

#### Command and Chain of Responsibility Patterns

To describe the design patterns and implementation, here is a run through of the key operations the code executes when a command is entered by the user. ```main.py``` runs the ```start()``` function of the app in ./calculator/\_\_init\_\_.py, which initializes the available plugins (commands) and enters a while loop that ends with either a keyboard interrupt or the exit command. The Calculator class is the Client of the command pattern.

```
def start(self):
        Calculator.load_plugins(self)
        logging.info("Calculator initialized")
        print("Calculator initialized\nType 'exit' to quit. Type 'menu' to see available commands.\n")

        while True:
            try:
                self.command_handler.handle_user_input(input("> ").strip())
            except KeyboardInterrupt:
                logging.info("Keyboard interrupt entered, now exiting program.")
                sys.exit(0)
```
The commands are handled through the Chain of Responsibility design pattern, and the function ```handle_user_input()``` in the CommandHandler class is where the chain begins. CommandHandler is also the Invoker of the Command pattern implementation. ```handle_user_input()``` is implemented in the CommandHandler class, which either passes the command and its arguments to ```execute_command()``` if it is valid, or informs the user that they have entered an invalid command if it is invalid. This is the first layer of input validation in the chain.

```
def handle_user_input(self, input: str):
        user_input = input.split()
        command_name = user_input[0]
        args = user_input[1:]
        try:
            if(command_name in {'add', 'subtract', 'multiply', 'divide'}):
                args = list(map(Decimal, args))
            self.execute_command(command_name, *args)
        except InvalidOperation:
            logging.error(f"Error: command '{command_name}' with invalid argument")
            print("Error: argument entered was not a valid number")
        except Exception as e:
            logging.error(f"Exception: {e}")
            print(f"Error: {e}")
```

In ```execute_command()```, a valid command is executed using its own execute function, optionally returning a value if it is a mathematical function. This is the Receiver of the command pattern.

```
def execute_command(self, command_name: str, *args):
        try:
            result = self.commands[command_name].execute(*args)
            if isinstance(result, Decimal):
                print(f"Result: {result}")
                HistoryManager.add_to_history(command_name, list(args), result)
            logging.info(f"Command '{command_name}' executed with arguments {args}.")
        except KeyError:
            logging.error(f"Command not recognized: {command_name}")
            print(f"Command not recognized: {command_name}")
```

Each of the available calculator commands is implemented as a subclass (Concrete Command) that inherits from the abstract class ```Command```, which defines a command as having an ```execute()``` function that performs its operation and optionally returns a value if applicable as well as two helper functions ```usage()``` and ```description()``` for the app menu, following the Command pattern. Below is the Command pattern interface, the abstract class Command:

```
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass
    @abstractmethod
    def description(self):
        pass
    @abstractmethod
    def usage(self):
        pass
```

Below is an example of the implementation of an arithmetic operation, a Concrete Command.

```
class AddCommand(Command):
    def execute(self, a: Decimal, b: Decimal) -> Decimal:
        return a + b
    
    def description(self):
        return "Add two operands: a + b"
    
    def usage(self):
        return "add <operand_a> <operand_b>"
```

Every command line function the user has access to is implemented as a Concrete Command, with these commands being add, subtract, multiply, divide, history, clearhistory, deletehistory, menu, and exit. <br>

Successful mathematical operations are recorded by the calculator into a history, stored as a csv file using pandas. This is determined by the command having a valid return value, as shown below:

```
def execute_command(self, command_name: str, *args):
    try:
        result = self.commands[command_name].execute(*args)
        if isinstance(result, Decimal):
            print(f"Result: {result}")
            HistoryManager.add_to_history(command_name, list(args), result)
...
```

This is done by the Singleton HistoryManager class, which uses class methods to access and write to the history csv file. It also provides a Facade for the rest of the program to keep the history manipulation commands clean and compact by performing csv to dataframe retrievals and conversions. The above code calls ```add_to_history()``` when a math operation is performed, which is written:

```
def add_to_history(cls, command_name:str, args, result):
    display_args = [float(arg) for arg in args]

    calc = {'Operation': [command_name], 'Arguments': [display_args], 'Result': [result]}
    df_calc = pd.DataFrame(calc)
    csv_file_path = os.path.join(cls.HISTORY_DIR, cls.HISTORY_FILE)
    if os.path.exists(csv_file_path):
        df_calc.to_csv(csv_file_path, mode='a', header=False, index=False)
    else:
        df_calc.to_csv(csv_file_path, mode='w', header=True, index=False)
        logging.info(f"Created history file {cls.HISTORY_FILE}")
```
The Facade performs the necessary checks and type casting required in order to save an operation, which greatly simplifies the ```execute_command()``` function by not having it interact directly with the history files. Another useful Facade is the ```get_history_as_df()``` function, which reads the history csv file, performs error handling, and returns the data the csv contained as a pandas dataframe, which is a function every histroy manipulation command uses. 

#### Plugin Architecture

The calculator is implemented using a flexible plugin architecture which dynamically discovers and loads available plugins, leaving room for future expansion and allowing for quick and easy implementation of new commands without having to edit any other part of the program.

```
def load_plugins(self):
    plugins_package = 'calculator.plugins'
    plugins_path = plugins_package.replace('.', '/')

    if not os.path.exists(plugins_path):
        logging.warning(f"Plugins path '{plugins_path}' not found")
        return

    for i, plugin_name, is_pkg in pkgutil.iter_modules([plugins_path]):
        if is_pkg:
            plugin_module = importlib.import_module(f'{plugins_package}.{plugin_name}')
            for item_name in dir(plugin_module):
                item = getattr(plugin_module, item_name)

                constructor_params = inspect.signature(item.__init__).parameters

                try:
                    if issubclass(item, (Command)):
                        if 'command_handler' in constructor_params:
                            self.command_handler.register_command(plugin_name, item(self.command_handler))
                        else:
                            self.command_handler.register_command(plugin_name, item())
                except TypeError:
                    continue
                except ImportError as e:
                    logging.error(f"Error loading plugin {plugin_name}: {e}")
```
The key is in the ```load_plugins()``` function. Here, the program automatically looks for modules in the plugin directory, loading valid modules and registering them as commands. As long as each new module is properly written as the abstract class Command defines, it will automatically be added to the list of possible commands a user can execute, leaving room for simple expansion of the calculator's capabilities.

#### Environment Variables

The calculator app saves the history of successful mathematical commands in a .csv file for persistent storage. The location of this file is configured with environment variables, as discussed previously in the setup and usage section. 

```
class HistoryManager:
    load_dotenv()
    HISTORY_DIR = os.getenv('HISTORY_DIR', './history')
    HISTORY_FILE = os.getenv('HISTORY_FILE', 'calculation_history.csv')
    ...
```
The HistoryManager class sets the directory based on the HISTORY_DIR environment variable (defaulting to ./history) and sets the file based on HISTORY_FILE (defaulting to calculation_history.csv). These environment variables can be configured in a .env file, as previously shown. <br>

Logging is also configured via environment variables. Setting the "LOGGING_CONF_PATH" environment variable in the .env file will set the location of the logging configuration file. By default, it is logging.conf.

```
def configure_logging(self):
    logging_conf_path = os.getenv('LOGGING_CONF_PATH', 'logging.conf')
    if os.path.exists(logging_conf_path):
        logging.config.fileConfig(logging_conf_path, disable_existing_loggers=False)
    else:
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logging.info("Logging configured.")
```

### Logging

Log messages are used throughout the program to record program behavior using info logs and maintain a record of errors with error logs. Log info messages are placed where new directories and files are created, which helps when debugging as well as with general app usage. Critical errors are logged as error messages.

```
def initialize_history(cls):
        if not os.path.exists(cls.HISTORY_DIR):
            os.makedirs(cls.HISTORY_DIR)
            logging.info(f"History directory created: {cls.HISTORY_DIR}")
        elif not os.access(cls.HISTORY_DIR, os.W_OK):
            logging.error(f"The directory {cls.HISTORY_DIR} is not writeable")
            return
        if not os.path.exists(os.path.join(cls.HISTORY_DIR, cls.HISTORY_FILE)):
            df = pd.DataFrame(columns=["Operation", "Arguments", "Result"])
            df.to_csv(HistoryManager.get_history_path(), index=False)
            logging.info(f"History file created at {HistoryManager.get_history_path()}")
```

In every try/except block throughout the program, a log message is recorded whenever an error is caught. Here is one example:
```
class DivideCommand(Command):
    def execute(self, a: Decimal, b: Decimal) -> Decimal:
        try:
            return a / b
        except ZeroDivisionError:
            logging.error("Divide by zero error")
            print("Math error: division by zero")
```

Every command run and the arguments they are run with are recorded with a log message. This in addition to the error log messages helps to debug the program. This aids in development to see if logically valid commands are not properly accounted for. It also helps trace the program in case an error arises in order to replicate bugs or the program state which may have caused the error.

```
def execute_command(self, command_name: str, *args):
        try:
            result = self.commands[command_name].execute(*args)
            if isinstance(result, Decimal):
                print(f"Result: {result}")
                HistoryManager.add_to_history(command_name, list(args), result)
            logging.info(f"Command '{command_name}' executed with arguments {args}.")
        except KeyError:
            logging.error(f"Command not recognized: {command_name}")
            print(f"Command not recognized: {command_name}")
```

Many log messages are recorded in the calculator class, because this initializes every plugin, creates necessary directories, and loads environment variables. If logs indicate these processes are unsuccessful, it gives direct information about where, when, and why the program has failed, allowing for easier debugging. Warnings are raised when critical file paths are not found. Here is an example of logging in the calculator class:

```
def load_plugins(self):
        plugins_package = 'calculator.plugins'
        plugins_path = plugins_package.replace('.', '/')

        if not os.path.exists(plugins_path):
            logging.warning(f"Plugins path '{plugins_path}' not found")
            return
...
```

Similarly, logging messages are recorded in critical parts of the CommandHandler class, notably where plugins are registered and executed. Errors logged at these critical points help debug program breaking code.

```
def register_command(self, command_name: str, command: Command):
        self.commands[command_name] = command
        logging.info(f"Command '{command_name}' registered.")

def execute_command(self, command_name: str, *args):
    try:
        result = self.commands[command_name].execute(*args)
        if isinstance(result, Decimal):
            print(f"Result: {result}")
            HistoryManager.add_to_history(command_name, list(args), result)
        logging.info(f"Command '{command_name}' executed with arguments {args}.")
    except KeyError:
        logging.error(f"Command not recognized: {command_name}")
        print(f"Command not recognized: {command_name}")
```
For usability, displaying these log messages on the command line is turned off. To turn it back on, simply add ,consoleHandler to the handlers in the logging.conf file like so:
```
[logger_root]
level=INFO
handlers=fileHandler,consoleHandler
```

### LBYL/EAFP
Both LBYL and EAFP approaches are used throughout the program. LBYL is used in situations where it is expected that exceptions will occur often, therefore a safeguard is placed before an operation is executed. In the calculator app, the assumption is that there will often be times where the calculator history is empty, the directory is not created, or the file does not exist, such as when the program is started for the first time, or if the user deletes directories or changes the save directory. Therefore, in these situations, if statements are used before any accesses are attempted. For example:

```
def initialize_history(cls):
    if not os.path.exists(cls.HISTORY_DIR):
        os.makedirs(cls.HISTORY_DIR)
        logging.info(f"History directory created: {cls.HISTORY_DIR}")
    elif not os.access(cls.HISTORY_DIR, os.W_OK):
        logging.error(f"The directory {cls.HISTORY_DIR} is not writeable")
        return
    if not os.path.exists(os.path.join(cls.HISTORY_DIR, cls.HISTORY_FILE)):
        df = pd.DataFrame(columns=["Operation", "Arguments", "Result"])
        df.to_csv(HistoryManager.get_history_path(), index=False)
        logging.info(f"History file created at {HistoryManager.get_history_path()}")
```
Additionally, LBYL is used in the implementation of commands with optional parameters, assuming that users will often execute the commands without the optional parameters. Below is an example for the history command, which may be used as-is or with filtering via an optional parameter:

```
def execute(self, *args):
    command_name = args[0] if len(args) > 0 else None

    df_history = HistoryManager.get_history_as_df()
    if command_name:
        df_history = df_history[df_history['Operation'].str.fullmatch(command_name, case=False, na=False)]
...
```
EAFP is used whenever it is assumed that the operations will be performed successfully a majority of the time. Here is a simple example with the division command:

```
class DivideCommand(Command):
    def execute(self, a: Decimal, b: Decimal) -> Decimal:
        try:
            return a / b
        except ZeroDivisionError:
            logging.error("Divide by zero error")
            print("Math error: division by zero")
```
It is expected that divide by zero operations will be rare, so whenever the error occurs the expection is caught, logged, and the user is informed of the error. An additional example would be in the ```execute_command()``` function, which assumes most commands will be executed and catches errors when they arise:

```
def execute_command(self, command_name: str, *args):
    try:
        result = self.commands[command_name].execute(*args)
        if isinstance(result, Decimal):
            print(f"Result: {result}")
            HistoryManager.add_to_history(command_name, list(args), result)
        logging.info(f"Command '{command_name}' executed with arguments {args}.")
    except KeyError:
        logging.error(f"Command not recognized: {command_name}")
        print(f"Command not recognized: {command_name}")
```

### Video Demonstration
[Watch a demonstration of the calculator's functions.](https://youtu.be/d3CiWL4Y2I8)